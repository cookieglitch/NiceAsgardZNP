<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Hardware Abstraction Layer: hal_mdb1.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>hal_mdb1.c File Reference</h1>
<p>Hardware Abstraction Layer (HAL) for the Smith Electronics Module Development Board (MDB1).  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="hal__mdb1_8h.html">hal_mdb1.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c7083f0131c4c7a3bbfeb0a3e2a90ec"></a><!-- doxytag: member="hal_mdb1.c::EXCLUDE_STATUS_LEDS" ref="a6c7083f0131c4c7a3bbfeb0a3e2a90ec" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EXCLUDE_STATUS_LEDS</b>&nbsp;&nbsp;&nbsp;0x3F</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31b8a0dffdb193bc46182e2afd13d6f7"></a><!-- doxytag: member="hal_mdb1.c::LED_TEST_DELAY" ref="a31b8a0dffdb193bc46182e2afd13d6f7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LED_TEST_DELAY</b>&nbsp;&nbsp;&nbsp;250</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a848a94a66500eaa5493f9a235bd8a3dc"></a><!-- doxytag: member="hal_mdb1.c::TIMER_MAX_SECONDS" ref="a848a94a66500eaa5493f9a235bd8a3dc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>TIMER_MAX_SECONDS</b>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f03ab5d527a13ad423e874f2c628a2f"></a><!-- doxytag: member="hal_mdb1.c::ADC_VREF_DELAY_MS" ref="a4f03ab5d527a13ad423e874f2c628a2f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ADC_VREF_DELAY_MS</b>&nbsp;&nbsp;&nbsp;17</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1d50b55c6dd054db1d36855cfa67cd0"></a><!-- doxytag: member="hal_mdb1.c::ADC_COUNT_TO_MILLIVOLT_MULTIPLIER" ref="ae1d50b55c6dd054db1d36855cfa67cd0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ADC_COUNT_TO_MILLIVOLT_MULTIPLIER</b>&nbsp;&nbsp;&nbsp;1.220703125</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">signed int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a06802a4f8cbb266f1ca8bdb46f462965">oscInit</a> (unsigned char mainOscConfiguration, unsigned char auxOscConfiguration)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__interrupt void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a1c27b12dfd9998dbc915bee092a83447">USCIAB0RX_ISR</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__interrupt void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#af08d888a69d655969bf7b79612847c95">USCI1RX_ISR</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#ae9ce04c109f0c34da1b84091547ddea6">getButtons</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__interrupt void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a6ddfaf32b7620184897c858c576dc5a3">PORT2_ISR</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30a6a305ab51297fa0e5020249726b20"></a><!-- doxytag: member="hal_mdb1.c::PORT1_ISR" ref="a30a6a305ab51297fa0e5020249726b20" args="(void)" -->
__interrupt void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PORT1_ISR</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#abc6c00d8d65f1bed6f2ce307998dada0">halInit</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">signed int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a10e7051cb609e38a72596d9088667873">debugConsoleInit</a> (unsigned char baudRate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">signed int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a3e02a3a9de5bd91f9bc03b58407ecbf7">auxSerialPortInit</a> (unsigned char baudRate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#af4de2514b7778805db3815e8dd6cf09a">putchar</a> (int c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a307cb2e2f71f62b5717971c0743184c5">putcharAux</a> (int c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a3c215d815192c172fe858d751071e9dd">halSpiInitZnp</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a8653a168989b0498a6bbfe865150d58c">spiWrite</a> (unsigned char *bytes, unsigned char numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a82513b466ae394b673bc365537fe2146">delayMs</a> (unsigned int ms)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a98042ceed91c323d713b8eaf1330578a">setStatusLed</a> (unsigned char color)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a7f62c9b5ce14a0962bbf56e532a0a44f">setButtonLeds</a> (unsigned char led)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">signed int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a5a0c8f1d5aaf7c4ce53ad9af0fe110ec">setLed</a> (unsigned char led)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a5801a13917aa5f680d836b0543c4100b">clearLeds</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a4c9b9a57a69edf4ef7d6a024ac5335d2">clearButtonLeds</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a67f724ff9563f197e92725de1aa01e43">toggleLed</a> (unsigned char whichLed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#ac601fe8e2ec9b20a2d3797dfa408ced9">testLEDs</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a279999fb4ab7e68771046e6b14ef162e">getSwitches</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#aaaf027a27a0d7feb1e85d4402926f12d">halEnableInterrupts</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a865c94e017f6ddb42d2e0e51f6a395c1">setZnpInterfaceToInputs</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d49322625fd8ba3dd0ec83ea1fe1cc8"></a><!-- doxytag: member="hal_mdb1.c::stopTimerA" ref="a0d49322625fd8ba3dd0ec83ea1fe1cc8" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>stopTimerA</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">signed int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a8861ee0f29013d6fed16952a41d986c0">initTimer</a> (unsigned char seconds, unsigned char wakeOnTimer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09ed4b2dbe24973d3f4b0a118fa06ee8"></a><!-- doxytag: member="hal_mdb1.c::Timer_A" ref="a09ed4b2dbe24973d3f4b0a118fa06ee8" args="(void)" -->
__interrupt void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Timer_A</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">signed int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#aea54cfa0b896d2e756d3eb75273a1710">calibrateVlo</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#aa2262660960fd17ecff498ce9143bc3f">getAnalogInput</a> (unsigned int adc12ctl0, unsigned int adc12ctl1, unsigned char adc12mctl0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a7979965bb7ea3b7faf9fcbdde116fe7b">getVcc3</a> ()</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a8ae091a60a9e1f4eef0b56268ed1f36b">debugConsoleIsr</a> )(char)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#adba3edf29f085eb5465a9d028be99143">buttonIsr</a> )(char)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#aaf473d7d866976957729b47a5554a4ad">timerIsr</a> )(void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a3c45efda7c559068f1d026b79c36e5c5">auxSerialPort</a> )(char)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#ace9761ce5b6f8de452f5ee43a28d6e87">bitBangSerialIsr</a> )(char)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#ad0066e8dbdccb03203819b6a338c52d1">mclk</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a616ece64fbf8efc80ef18cf3ecdfc4ba"></a><!-- doxytag: member="hal_mdb1.c::smclk" ref="a616ece64fbf8efc80ef18cf3ecdfc4ba" args="" -->
unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><b>smclk</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf9761c8fd3f159f938f5ad2c68633a7"></a><!-- doxytag: member="hal_mdb1.c::aClk" ref="aaf9761c8fd3f159f938f5ad2c68633a7" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>aClk</b> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73fbf816dbe66af08f09d0968815cc6d"></a><!-- doxytag: member="hal_mdb1.c::wakeupAfterTimer" ref="a73fbf816dbe66af08f09d0968815cc6d" args="" -->
unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><b>wakeupAfterTimer</b> = 0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Hardware Abstraction Layer (HAL) for the Smith Electronics Module Development Board (MDB1). </p>
<p>This development board has an MSP430F248 and CC2530ZNP and was the initial development platform for these ZNP Examples. This file is included to show how easy it is to port the ZNP libraries to a different hardware platform.</p>
<p>Peripherals:</p>
<ul>
<li>ZNP Interface: Connects to the ZNP via jumper-selectable SPI or UART</li>
<li>LEDs: Six general purpose LEDs, one bi-color (Red/Yellow/Green) Status LED, and one power LED</li>
<li>Buttons: Five general purpose buttons, one reset button</li>
<li>Interfaces: MSP430 &amp; CC2530 programming connectors, RS-232 on DB-9</li>
<li>Crystals: External 32kHz and 16MHz crystal options</li>
<li>I2C Serial EEPROM</li>
<li>Other I/O: Two Opto-Isolated inputs, Four relay drivers, I/O pins on headers</li>
<li>Configurability: All on-board peripherals may be disabled with cuttable jumpers See www.smith-electronics.com for more information.</li>
</ul>
<dl class="rcs"><dt><b>Rev</b></dt><dd>709 </dd></dl>
<dl class="rcs"><dt><b>Author</b></dt><dd>dsmith </dd></dl>
<dl class="rcs"><dt><b>Date</b></dt><dd>2010-08-12 19:00:00 -0700 (Thu, 12 Aug 2010) </dd></dl>
<p>YOU ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a3e02a3a9de5bd91f9bc03b58407ecbf7"></a><!-- doxytag: member="hal_mdb1.c::auxSerialPortInit" ref="a3e02a3a9de5bd91f9bc03b58407ecbf7" args="(unsigned char baudRate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed int auxSerialPortInit </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>baudRate</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures the Auxilliary Serial Port UART (USCIA1) with the specified baud rate. Also enables the Rx interrupt for this UART. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>SMCLK = 4MHz </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if success, -1 if invalid parameter </dd></dl>

</div>
</div>
<a class="anchor" id="aea54cfa0b896d2e756d3eb75273a1710"></a><!-- doxytag: member="hal_mdb1.c::calibrateVlo" ref="aea54cfa0b896d2e756d3eb75273a1710" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed int calibrateVlo </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calibrate VLO. Once this is done, the VLO can be used semi-accurately for timers etc. Once calibrated, VLO is within ~2% of actual when using a 1% calibrated DCO frequency and temperature and supply voltage remain unchanged. At room temperature, typical VLO frequencies seen are 9kHz (MSP430F248) and 12kHz (MSP430F2274) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>VLO frequency (number of VLO counts in 1sec) </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>SMCLK is 4MHz </dd>
<dd>
MCLK is 8MHz </dd>
<dd>
ACLK sourced by VLO (BCSCTL3 = LFXT1S_2; in MSP430F2xxx) </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>calibration is only as good as MCLK source. Obviously, if using the internal DCO (+/- 1%) then this value will only be as good as +/- 1%. YMMV. </dd>
<dd>
on MSP430F248 or MSP430F22x2 or MSP430F22x4, must use TACCR2. On MSP430F20x2, must use TACCR0. Check device-specific datasheet to see which module block has ACLK as a compare input. For example, see page 23 of the MSP430F24x datasheet or page 17 of the MSP430F20x2 datasheet, or page 18 of the MSP430F22x4 datasheet. </dd>
<dd>
if application will require accuracy over change in temperature or supply voltage, recommend calibrating VLO more often. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>Timer A settings changed </dd>
<dd>
ACLK divide by 8 bit cleared </dd></dl>

</div>
</div>
<a class="anchor" id="a4c9b9a57a69edf4ef7d6a024ac5335d2"></a><!-- doxytag: member="hal_mdb1.c::clearButtonLeds" ref="a4c9b9a57a69edf4ef7d6a024ac5335d2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearButtonLeds </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Turns off the button LEDs and leaves status LED unchanged. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>button LEDs are all off. Status LED is in the same state as it was before the method was called. </dd></dl>

</div>
</div>
<a class="anchor" id="a5801a13917aa5f680d836b0543c4100b"></a><!-- doxytag: member="hal_mdb1.c::clearLeds" ref="a5801a13917aa5f680d836b0543c4100b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearLeds </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Turns OFF the specified LED. Required for ZNP examples. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>led</em>&nbsp;</td><td>the LED to turn off, must be 0,1,2,3,4. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if success, -1 if invalid LED specified </dd></dl>

</div>
</div>
<a class="anchor" id="a10e7051cb609e38a72596d9088667873"></a><!-- doxytag: member="hal_mdb1.c::debugConsoleInit" ref="a10e7051cb609e38a72596d9088667873" args="(unsigned char baudRate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed int debugConsoleInit </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>baudRate</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures the debug console UART (USCIA0) for the specified baud rate, with oversampling Also enables the Rx interrupt for this UART. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>SMCLK is 4MHz </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>Table 15-5 of MSP430F2xxx Family User's Guide, slau144 </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if success, -1 if invalid parameter </dd></dl>

</div>
</div>
<a class="anchor" id="a82513b466ae394b673bc365537fe2146"></a><!-- doxytag: member="hal_mdb1.c::delayMs" ref="a82513b466ae394b673bc365537fe2146" args="(unsigned int ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delayMs </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>ms</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Blocking Delay in Milliseconds delays by at least the specified number of milliseconds (ms) </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>TICKS_PER_MS set </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ms</em>&nbsp;</td><td>number of milliseconds to delay </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2262660960fd17ecff498ce9143bc3f"></a><!-- doxytag: member="hal_mdb1.c::getAnalogInput" ref="aa2262660960fd17ecff498ce9143bc3f" args="(unsigned int adc12ctl0, unsigned int adc12ctl1, unsigned char adc12mctl0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int getAnalogInput </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>adc12ctl0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>adc12ctl1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>adc12mctl0</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Private helper method to setup ADC for one-shot conversion and read out value according to registers. Inserts a delay before beginning conversion if REFON </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the raw ADC value with the specified commands. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>move the VREF warmup to startup and leave on to avoid 17mSec blocking delay each time? </dd></dl>

</div>
</div>
<a class="anchor" id="ae9ce04c109f0c34da1b84091547ddea6"></a><!-- doxytag: member="hal_mdb1.c::getButtons" ref="ae9ce04c109f0c34da1b84091547ddea6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char getButtons </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the current status of the buttons </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0x01 if button 1 is pressed, 0x02 if button 2 is pressed, 0x04 if button 3 is pressed, etc. </dd></dl>

</div>
</div>
<a class="anchor" id="a279999fb4ab7e68771046e6b14ef162e"></a><!-- doxytag: member="hal_mdb1.c::getSwitches" ref="a279999fb4ab7e68771046e6b14ef162e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char getSwitches </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read value of the two Dual In-Line Package (DIP) switches. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the state of the switches as a number from 0 to 3. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>DIP Switches (P2.6, P2.7) are configured as digital inputs with pull-DOWNs </dd></dl>

</div>
</div>
<a class="anchor" id="a7979965bb7ea3b7faf9fcbdde116fe7b"></a><!-- doxytag: member="hal_mdb1.c::getVcc3" ref="a7979965bb7ea3b7faf9fcbdde116fe7b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int getVcc3 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Measures Vcc to the MSP430, nominally 3300mV</p>
<ul>
<li>ADC measures VCC/2 compared to 2.5V reference</li>
<li>If Vcc = 3.3V, ADC output should be (1.65/2.5)*4095 = 2703</li>
<li>(halfVcc/2.5)*4095 = ADC reading and (Vcc/2.5)*4095 = 2*ADC</li>
<li>Vcc*4096 = 5*ADC --&gt; and VCC=5*ADC/4095</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>Vcc in millivolts </dd></dl>

</div>
</div>
<a class="anchor" id="aaaf027a27a0d7feb1e85d4402926f12d"></a><!-- doxytag: member="hal_mdb1.c::halEnableInterrupts" ref="aaaf027a27a0d7feb1e85d4402926f12d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halEnableInterrupts </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable interrupts on the processor </p>

</div>
</div>
<a class="anchor" id="abc6c00d8d65f1bed6f2ce307998dada0"></a><!-- doxytag: member="hal_mdb1.c::halInit" ref="abc6c00d8d65f1bed6f2ce307998dada0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halInit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures hardware for the particular board</p>
<ul>
<li>Oscillator: turns off WDT, configures MCLK &amp; SMCLK</li>
<li>Ports: including purpose, direction, pullup/pulldown resistors etc.</li>
<li>Holds radio in reset (active-low) </li>
</ul>

</div>
</div>
<a class="anchor" id="a3c215d815192c172fe858d751071e9dd"></a><!-- doxytag: member="hal_mdb1.c::halSpiInitZnp" ref="a3c215d815192c172fe858d751071e9dd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halSpiInitZnp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the SPI interface to the ZNP. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>CC2530 SPI clock speed &lt; 4MHz. SPI port configured for clock polarity of 0, clock phase of 0, and MSB first. </dd>
<dd>
On MDB the RFIC SPI port is USCIB1 </dd>
<dd>
Modify this method for other hardware implementations. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>SPI pins configured correctly: Clock, MOSI, MISO configured as SPI function; Chip Select configured as an output; SRDY configured as an input. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>SPI port is configured for RFIC communications. </dd></dl>

</div>
</div>
<a class="anchor" id="a8861ee0f29013d6fed16952a41d986c0"></a><!-- doxytag: member="hal_mdb1.c::initTimer" ref="a8861ee0f29013d6fed16952a41d986c0" args="(unsigned char seconds, unsigned char wakeOnTimer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed int initTimer </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>seconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>wakeOnTimer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures timer for source = ACLK </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>ACLK configured </dd>
<dd>
VLO has been calibrated if using VLO; number of VLO counts in one second is in vloFrequency. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>seconds</em>&nbsp;</td><td>period of the timer. Maximum is 0xFFFF / aClk; about 2 if using 32kHz xtal or about 4 if using VLO since VLO varies between 9kHz - 15kHz. Use a prescaler on timer (e.g. set IDx bits in TACTL register) for longer times. Maximum prescaling of Timer A is divide by 8. Even longer times can be obtained by prescaling ACLK if this doesn't affect other system peripherals. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if success; -1 if illegal parameter or -2 if aClk not set </dd></dl>

</div>
</div>
<a class="anchor" id="a06802a4f8cbb266f1ca8bdb46f462965"></a><!-- doxytag: member="hal_mdb1.c::oscInit" ref="a06802a4f8cbb266f1ca8bdb46f462965" args="(unsigned char mainOscConfiguration, unsigned char auxOscConfiguration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed int oscInit </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>mainOscConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>auxOscConfiguration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stops the Watchdog timer and starts Oscillator based on the selected option. Halts if calibration constants erased. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mainOscConfiguration</em>&nbsp;</td><td>the main oscillator (MCLK) configuration - must be MCLK_1_DCO or MCLK_8_DCO or MCLK_8_XTAL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auxOscConfiguration</em>&nbsp;</td><td>the aux oscillator (ACLK) configuration - must be ACLK_VLO or ACLK_32_XTAL or ACLK_32_EXT </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if success, else error code if invalid parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ddfaf32b7620184897c858c576dc5a3"></a><!-- doxytag: member="hal_mdb1.c::PORT2_ISR" ref="a6ddfaf32b7620184897c858c576dc5a3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__interrupt void PORT2_ISR </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Port P2 interrupt service routine. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Port 2 pins are configured as interrupts appropriately. </dd></dl>

</div>
</div>
<a class="anchor" id="af4de2514b7778805db3815e8dd6cf09a"></a><!-- doxytag: member="hal_mdb1.c::putchar" ref="af4de2514b7778805db3815e8dd6cf09a" args="(int c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int putchar </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send one byte via hardware UART. Called by printf() etc. in stdio.h </p>

</div>
</div>
<a class="anchor" id="a307cb2e2f71f62b5717971c0743184c5"></a><!-- doxytag: member="hal_mdb1.c::putcharAux" ref="a307cb2e2f71f62b5717971c0743184c5" args="(int c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int putcharAux </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send one byte via hardware UART to the auxilliary serial port. Aux Serial Port is USCIA1 </p>

</div>
</div>
<a class="anchor" id="a7f62c9b5ce14a0962bbf56e532a0a44f"></a><!-- doxytag: member="hal_mdb1.c::setButtonLeds" ref="a7f62c9b5ce14a0962bbf56e532a0a44f" args="(unsigned char led)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setButtonLeds </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>led</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Turns on the specified button LED. Leaves status LED unchanged. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Button LEDs are active-LOW, Status LED is active-HIGH. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>whichLed</em>&nbsp;</td><td>the LED to turn on, must be 0-4. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a0c8f1d5aaf7c4ce53ad9af0fe110ec"></a><!-- doxytag: member="hal_mdb1.c::setLed" ref="a5a0c8f1d5aaf7c4ce53ad9af0fe110ec" args="(unsigned char led)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed int setLed </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>led</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Turns ON the specified LED. Required for ZNP examples. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>led</em>&nbsp;</td><td>the LED to turn on, must be 0,1,2,3,4. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if success, -1 if invalid LED specified </dd></dl>

</div>
</div>
<a class="anchor" id="a98042ceed91c323d713b8eaf1330578a"></a><!-- doxytag: member="hal_mdb1.c::setStatusLed" ref="a98042ceed91c323d713b8eaf1330578a" args="(unsigned char color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setStatusLed </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>color</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the status LED to a particular color. Leaves the other LEDs unchanged. The status LED is a two-element LED (red+green) that is capable of displaying red, green, or yellow. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Button LEDs are active-LOW, Status LED is active-HIGH. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>the color to set, must be STATUS_LED_RED, STATUS_LED_GREEN, or STATUS_LED_YELLOW. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a865c94e017f6ddb42d2e0e51f6a395c1"></a><!-- doxytag: member="hal_mdb1.c::setZnpInterfaceToInputs" ref="a865c94e017f6ddb42d2e0e51f6a395c1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setZnpInterfaceToInputs </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures all ZNP interface signals as inputs to allow the ZNP to be programmed. Toggles LED0 quickly to indicate application is running. </p>

</div>
</div>
<a class="anchor" id="a8653a168989b0498a6bbfe865150d58c"></a><!-- doxytag: member="hal_mdb1.c::spiWrite" ref="a8653a168989b0498a6bbfe865150d58c" args="(unsigned char *bytes, unsigned char numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spiWrite </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a message over SPI to the radio IC on USCI_B1. Based on hal_board.c in CC2480 example application ZASA. The ZNP uses a "write-to-read" approach to read data out, you must write data in. This is a private method that gets wrapped by other methods, e.g. spiSreq(), spiAreq, etc. To Write, set *bytes, numBytes. To Read, set *bytes only. Don't need to set numBytes because CC2530ZNP will stop when no more bytes read. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bytes</em>&nbsp;</td><td>the data to be sent or received. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numBytes</em>&nbsp;</td><td>the number of bytes to be sent. This same buffer will be overwritten with the received data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Modify this method for other hardware implementations. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>SPI port configured for writing </dd>
<dd>
CC2530ZNP has been initialized </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>bytes contains received data, if any </dd></dl>

</div>
</div>
<a class="anchor" id="ac601fe8e2ec9b20a2d3797dfa408ced9"></a><!-- doxytag: member="hal_mdb1.c::testLEDs" ref="ac601fe8e2ec9b20a2d3797dfa408ced9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void testLEDs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Simple test of all LEDs </p>

</div>
</div>
<a class="anchor" id="a67f724ff9563f197e92725de1aa01e43"></a><!-- doxytag: member="hal_mdb1.c::toggleLed" ref="a67f724ff9563f197e92725de1aa01e43" args="(unsigned char whichLed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void toggleLed </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>whichLed</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Toggles the specified button LED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>whichLed</em>&nbsp;</td><td>the LED to toggle, must be 0-4. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The specified button LED is toggled. Status LED is unchanged. </dd></dl>

</div>
</div>
<a class="anchor" id="af08d888a69d655969bf7b79612847c95"></a><!-- doxytag: member="hal_mdb1.c::USCI1RX_ISR" ref="af08d888a69d655969bf7b79612847c95" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__interrupt void USCI1RX_ISR </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Auxilliary Serial Port interrupt service routine, called when a byte is received on USCIA1 or USCIB1. </p>

</div>
</div>
<a class="anchor" id="a1c27b12dfd9998dbc915bee092a83447"></a><!-- doxytag: member="hal_mdb1.c::USCIAB0RX_ISR" ref="a1c27b12dfd9998dbc915bee092a83447" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__interrupt void USCIAB0RX_ISR </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Debug console interrupt service routine, called when a byte is received on USCIA0 or USCIB0. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a3c45efda7c559068f1d026b79c36e5c5"></a><!-- doxytag: member="hal_mdb1.c::auxSerialPort" ref="a3c45efda7c559068f1d026b79c36e5c5" args=")(char)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="hal__mdb1_8c.html#a3c45efda7c559068f1d026b79c36e5c5">auxSerialPort</a>)(char)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function pointer for the ISR called when a byte is received on the aux. serial port </p>

</div>
</div>
<a class="anchor" id="ace9761ce5b6f8de452f5ee43a28d6e87"></a><!-- doxytag: member="hal_mdb1.c::bitBangSerialIsr" ref="ace9761ce5b6f8de452f5ee43a28d6e87" args=")(char)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="hal__mdb1_8c.html#ace9761ce5b6f8de452f5ee43a28d6e87">bitBangSerialIsr</a>)(char)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function pointer for the ISR called when a byte is received on the bit-bang serial port. Param is which bit-bang interface (0 or 1) </p>

</div>
</div>
<a class="anchor" id="adba3edf29f085eb5465a9d028be99143"></a><!-- doxytag: member="hal_mdb1.c::buttonIsr" ref="adba3edf29f085eb5465a9d028be99143" args=")(char)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="hal__mdb1_8c.html#adba3edf29f085eb5465a9d028be99143">buttonIsr</a>)(char)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function pointer for the ISR called when a button is pressed. </p>

</div>
</div>
<a class="anchor" id="a8ae091a60a9e1f4eef0b56268ed1f36b"></a><!-- doxytag: member="hal_mdb1.c::debugConsoleIsr" ref="a8ae091a60a9e1f4eef0b56268ed1f36b" args=")(char)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="hal__mdb1_8c.html#a8ae091a60a9e1f4eef0b56268ed1f36b">debugConsoleIsr</a>)(char)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is a function pointer for the Interrupt Service Routine called when a debug console character is received. To use it, declare it with <code> extern void (*debugConsoleIsr)(char); </code> and then point it to a function you created, e.g. <code> debugConsoleIsr =  </code> and your function handleDebugConsoleInterrupt() will be called when a byte is received. </p>

</div>
</div>
<a class="anchor" id="ad0066e8dbdccb03203819b6a338c52d1"></a><!-- doxytag: member="hal_mdb1.c::mclk" ref="ad0066e8dbdccb03203819b6a338c52d1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="hal__mdb1_8c.html#ad0066e8dbdccb03203819b6a338c52d1">mclk</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For total code + CONST size of 29k, (as of 1/28/10) flash up to 0x5669 is in use. time for segment erase = 4819/fFTG, or about 12mSec time for block program is about 1.73mSec per Block, so total per segment is approx. 15mSec. If writing entire 30kB firmware image (60segments) then total time is ~900mSec. Total time spent programming each block must be less than 4mSec. (i.e. don't include much stuff inbetween writing bytes) </p>

</div>
</div>
<a class="anchor" id="aaf473d7d866976957729b47a5554a4ad"></a><!-- doxytag: member="hal_mdb1.c::timerIsr" ref="aaf473d7d866976957729b47a5554a4ad" args=")(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="hal__mdb1_8c.html#aaf473d7d866976957729b47a5554a4ad">timerIsr</a>)(void)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function pointer for the ISR called when a timer generates an interrupt </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Aug 19 11:48:31 2010 for Hardware Abstraction Layer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
