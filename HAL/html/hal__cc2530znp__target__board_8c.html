<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Hardware Abstraction Layer: hal_cc2530znp_target_board.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>hal_cc2530znp_target_board.c File Reference</h1>
<p>Hardware Abstraction Layer (HAL) for the cc2530znp target board.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="hal__cc2530znp__target__board_8c.html">hal_cc2530znp_target_board.h</a>&quot;</code><br/>
<code>#include &quot;msp430x22x4.h&quot;</code><br/>
<code>#include &quot;../Common/printf.h&quot;</code><br/>
<code>#include &quot;../Common/utilities.h&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9a9534e8cef487fde5558fdece4748f"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::HARDWARE_UART" ref="aa9a9534e8cef487fde5558fdece4748f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>HARDWARE_UART</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a848a94a66500eaa5493f9a235bd8a3dc"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::TIMER_MAX_SECONDS" ref="a848a94a66500eaa5493f9a235bd8a3dc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>TIMER_MAX_SECONDS</b>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__interrupt void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a1c27b12dfd9998dbc915bee092a83447">USCIAB0RX_ISR</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__interrupt void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a30a6a305ab51297fa0e5020249726b20">PORT1_ISR</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__interrupt void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a6ddfaf32b7620184897c858c576dc5a3">PORT2_ISR</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#abc6c00d8d65f1bed6f2ce307998dada0">halInit</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">signed int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a468209e5057f8875dfa7c6fa8d736a6c">halConfigureSrdyInterrrupt</a> (unsigned char flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#af4de2514b7778805db3815e8dd6cf09a">putchar</a> (int c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a3c215d815192c172fe858d751071e9dd">halSpiInitZnp</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a8653a168989b0498a6bbfe865150d58c">spiWrite</a> (unsigned char *bytes, unsigned char numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a82513b466ae394b673bc365537fe2146">delayMs</a> (unsigned int ms)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a575d5bd90f078d3bf229c1085e426f3f">delayUs</a> (unsigned int us)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">signed int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a5a0c8f1d5aaf7c4ce53ad9af0fe110ec">setLed</a> (unsigned char led)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a5801a13917aa5f680d836b0543c4100b">clearLeds</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">signed int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a84e7d920fe8baceca080352f2c9c6fb0">toggleLed</a> (unsigned char led)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a7979965bb7ea3b7faf9fcbdde116fe7b">getVcc3</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#aa8754d9b3c320123c3fe1c5aca480886">getLightSensor</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a46877144ac24ce10d31daf63a8ff94cc">halSpiInitAccelerometer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">signed int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#aa6f874cb5178476d7927d40bafe93634">halEnableAccelerometerInterrupt</a> (unsigned char wakeOnAccelerometer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb11ec7bc175239767629730187a951d"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::spiWriteAccelerometer" ref="afb11ec7bc175239767629730187a951d" args="(unsigned char b)" -->
unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><b>spiWriteAccelerometer</b> (unsigned char b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a865c94e017f6ddb42d2e0e51f6a395c1">setZnpInterfaceToInputs</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">signed int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a8861ee0f29013d6fed16952a41d986c0">initTimer</a> (unsigned char seconds, unsigned char wakeOnTimer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6f6bfef028c7b053444cbd48567d286"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::stopTimer" ref="aa6f6bfef028c7b053444cbd48567d286" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>stopTimer</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09ed4b2dbe24973d3f4b0a118fa06ee8"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::Timer_A" ref="a09ed4b2dbe24973d3f4b0a118fa06ee8" args="(void)" -->
__interrupt void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Timer_A</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">signed int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#aea54cfa0b896d2e756d3eb75273a1710">calibrateVlo</a> ()</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a8ae091a60a9e1f4eef0b56268ed1f36b">debugConsoleIsr</a> )(char)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#adba3edf29f085eb5465a9d028be99143">buttonIsr</a> )(char)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#aaf473d7d866976957729b47a5554a4ad">timerIsr</a> )(void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a5a2a60dd6e60be649eb41d656a73cb94">accelerometerIsr</a> )(void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a20e13adfc540d264097a7733c36d65a7">srdyIsr</a> )(void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#ade29a27c903a705ca10a52e6d690e7ac">wakeupFlags</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__cc2530znp__target__board_8c.html#a1d9ae5b74e1b201388cff33a7537d3c4">vloFrequency</a> = 0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Hardware Abstraction Layer (HAL) for the cc2530znp target board. </p>
<p>This file must be modified if changing hardware platforms.</p>
<p>The ZNP library &amp; examples require the following methods to be implemented. Refer to the individual method descriptions for more information.</p>
<ul>
<li><a class="el" href="hal__cc2530znp__target__board_8c.html#abc6c00d8d65f1bed6f2ce307998dada0">halInit()</a></li>
<li><a class="el" href="hal__cc2530znp__target__board_8c.html#af4de2514b7778805db3815e8dd6cf09a">putchar()</a></li>
<li><a class="el" href="hal__cc2530znp__target__board_8c.html#a3c215d815192c172fe858d751071e9dd">halSpiInitZnp()</a></li>
<li><a class="el" href="hal__cc2530znp__target__board_8c.html#a82513b466ae394b673bc365537fe2146">delayMs()</a></li>
<li><a class="el" href="hal__cc2530znp__target__board_8c.html#a84e7d920fe8baceca080352f2c9c6fb0">toggleLed()</a></li>
</ul>
<p>Also see <a class="el" href="hal__cc2530znp__target__board_8h.html" title="public methods for hal_cc2530znp_target_board.c">hal_cc2530znp_target_board.h</a> for macros that must be defined.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="hal__helper_8c.html" title="Utilities to assist changing hardware platforms.">hal_helper.c</a> for utilities to assist when changing hardware platforms</dd>
<dd>
<a href="http://processors.wiki.ti.com/index.php/Tutorial_on_the_Examples">http://processors.wiki.ti.com/index.php/Tutorial_on_the_Examples</a> and <a href="http://e2e.ti.com/support/low_power_rf/default.aspx">http://e2e.ti.com/support/low_power_rf/default.aspx</a></dd></dl>
<dl class="rcs"><dt><b>Rev</b></dt><dd>658 </dd></dl>
<dl class="rcs"><dt><b>Author</b></dt><dd>dsmith </dd></dl>
<dl class="rcs"><dt><b>Date</b></dt><dd>2010-07-13 10:23:50 -0700 (Tue, 13 Jul 2010) </dd></dl>
<p>YOU ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aea54cfa0b896d2e756d3eb75273a1710"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::calibrateVlo" ref="aea54cfa0b896d2e756d3eb75273a1710" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed int calibrateVlo </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calibrate VLO. Once this is done, the VLO can be used semi-accurately for timers etc. Once calibrated, VLO is within ~2% of actual when using a 1% calibrated DCO frequency and temperature and supply voltage remain unchanged. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>VLO frequency (number of VLO counts in 1sec), or -1 if out of range </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>SMCLK is 4MHz </dd>
<dd>
MCLK is 8MHz </dd>
<dd>
ACLK sourced by VLO (BCSCTL3 = LFXT1S_2; in MSP430F2xxx) </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Calibration is only as good as MCLK source. Obviously, if using the internal DCO (+/- 1%) then this value will only be as good as +/- 1%. YMMV. </dd>
<dd>
On MSP430F248 or MSP430F22x2 or MSP430F22x4, must use TACCR2. On MSP430F20x2, must use TACCR0. Check device-specific datasheet to see which module block has ACLK as a compare input. For example, see page 23 of the MSP430F24x datasheet or page 17 of the MSP430F20x2 datasheet, or page 18 of the MSP430F22x4 datasheet. </dd>
<dd>
If application will require accuracy over change in temperature or supply voltage, recommend calibrating VLO more often. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>Timer A settings changed </dd>
<dd>
ACLK divide by 8 bit cleared </dd></dl>

</div>
</div>
<a class="anchor" id="a5801a13917aa5f680d836b0543c4100b"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::clearLeds" ref="a5801a13917aa5f680d836b0543c4100b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearLeds </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Turns OFF LEDs. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>LEDs are turned off. </dd></dl>

</div>
</div>
<a class="anchor" id="a82513b466ae394b673bc365537fe2146"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::delayMs" ref="a82513b466ae394b673bc365537fe2146" args="(unsigned int ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delayMs </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>ms</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Blocking Delay in Milliseconds delays by at least the specified number of milliseconds (ms) </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>TICKS_PER_MS set </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ms</em>&nbsp;</td><td>number of milliseconds to delay </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a575d5bd90f078d3bf229c1085e426f3f"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::delayUs" ref="a575d5bd90f078d3bf229c1085e426f3f" args="(unsigned int us)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delayUs </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>us</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Blocking Delay in Microseconds delays by at least the specified number of microseconds (us) </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>TICKS_PER_US set </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>us</em>&nbsp;</td><td>number of microseconds to delay </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8754d9b3c320123c3fe1c5aca480886"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::getLightSensor" ref="aa8754d9b3c320123c3fe1c5aca480886" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int getLightSensor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the light sensor. Turns on Light sensor, configures ADC, reads the value, and converts it to lux. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Light sensor outputs current between 0 to 50uA. On the target board, load resistor = 47k Ohms. </dd>
<dd>
0 to 100,000lx will generate 0 to 2350mV input into our ADC. </dd>
<dd>
Light sensor analog input is on P2.0, or analog input A0. </dd>
<dd>
This light sensor is binned for a sensitivity of 27 to 30 uA @ 1000lux = 1269-1410 mV = ADC readings of 520-578counts </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Light Sensor reading in lux/10. </dd></dl>

</div>
</div>
<a class="anchor" id="a7979965bb7ea3b7faf9fcbdde116fe7b"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::getVcc3" ref="a7979965bb7ea3b7faf9fcbdde116fe7b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int getVcc3 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the MSP430 supply voltage using the Analog to Digital Converter (ADC). On CC2530ZNP target board, this is approx. 3600mV </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Vcc supply voltage, in millivolts </dd></dl>

</div>
</div>
<a class="anchor" id="a468209e5057f8875dfa7c6fa8d736a6c"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::halConfigureSrdyInterrrupt" ref="a468209e5057f8875dfa7c6fa8d736a6c" args="(unsigned char flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed int halConfigureSrdyInterrrupt </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>flags</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures SRDY interrupt. Does NOT enable the interrupt. On the CC2530 target board, SRDY is P2.6 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>the options for the SRDY interrupt:</p>
<ul>
<li>SRDY_INTERRUPT_FALLING_EDGE or SRDY_INTERRUPT_RISING_EDGE</li>
<li>NO_WAKEUP or WAKEUP_AFTER_SRDY</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if success, -1 if bad flag </dd></dl>

</div>
</div>
<a class="anchor" id="aa6f874cb5178476d7927d40bafe93634"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::halEnableAccelerometerInterrupt" ref="aa6f874cb5178476d7927d40bafe93634" args="(unsigned char wakeOnAccelerometer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed int halEnableAccelerometerInterrupt </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>wakeOnAccelerometer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables the interrupt on the accelerometer (P1.3). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wakeOnAccelerometer</em>&nbsp;</td><td>whether to wakeup after this int is triggered. Must be either NO_WAKEUP or WAKEUP_AFTER_ACCELEROMETER. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if success; -1 if invalid wakeOnAccelerometer parameter </dd></dl>

</div>
</div>
<a class="anchor" id="abc6c00d8d65f1bed6f2ce307998dada0"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::halInit" ref="abc6c00d8d65f1bed6f2ce307998dada0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halInit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures hardware for the particular hardware platform:</p>
<ul>
<li>Ports: sets direction, interrupts, pullup/pulldown resistors etc.</li>
<li>Oscillator: turns off WDT, configures MCLK = 8MHz using internal DCO &amp; sets SMCLK = 4MHz</li>
<li>Holds radio in reset (active-low) </li>
</ul>

</div>
</div>
<a class="anchor" id="a46877144ac24ce10d31daf63a8ff94cc"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::halSpiInitAccelerometer" ref="a46877144ac24ce10d31daf63a8ff94cc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halSpiInitAccelerometer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the SPI port for the Accelerometer. Required because accelerometer SPI port uses different settings than the ZNP SPI port </p>

</div>
</div>
<a class="anchor" id="a3c215d815192c172fe858d751071e9dd"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::halSpiInitZnp" ref="a3c215d815192c172fe858d751071e9dd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halSpiInitZnp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the Serial Peripheral Interface (SPI) interface to the Zigbee Network Processor (ZNP). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Maximum CC2530ZNP SPI clock speed is 4MHz. SPI port configured for clock polarity of 0, clock phase of 0, and MSB first. </dd>
<dd>
On the CC2530ZNP target board the MSP430 uses USCIB0 SPI port to communicate with the ZNP </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>SPI pins configured correctly: Clock, MOSI, MISO configured as SPI function; Chip Select configured as an output; SRDY configured as an input. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>SPI port is configured for ZNP communications. </dd></dl>

</div>
</div>
<a class="anchor" id="a8861ee0f29013d6fed16952a41d986c0"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::initTimer" ref="a8861ee0f29013d6fed16952a41d986c0" args="(unsigned char seconds, unsigned char wakeOnTimer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed int initTimer </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>seconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>wakeOnTimer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures timer. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>ACLK sourced from VLO </dd>
<dd>
VLO has been calibrated; number of VLO counts in one second is in vloFrequency. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>seconds</em>&nbsp;</td><td>period of the timer. Maximum is 0xFFFF / vloFrequency; or about 4 since VLO varies between 9kHz - 15kHz. Use a prescaler on timer (e.g. set IDx bits in TACTL register) for longer times. Maximum prescaling of Timer A is divide by 8. Even longer times can be obtained by prescaling ACLK if this doesn't affect other system peripherals. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wakeOnTimer</em>&nbsp;</td><td>whether to wake the processor after the timer interrupt. Must be either NO_WAKEUP or WAKEUP_AFTER_TIMER. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if success; -1 if illegal parameter or -2 if VLO not calibrated </dd></dl>

</div>
</div>
<a class="anchor" id="a30a6a305ab51297fa0e5020249726b20"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::PORT1_ISR" ref="a30a6a305ab51297fa0e5020249726b20" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__interrupt void PORT1_ISR </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Port 1 interrupt service routine. </p>

</div>
</div>
<a class="anchor" id="a6ddfaf32b7620184897c858c576dc5a3"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::PORT2_ISR" ref="a6ddfaf32b7620184897c858c576dc5a3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__interrupt void PORT2_ISR </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Port 2 interrupt service routine. </p>

</div>
</div>
<a class="anchor" id="af4de2514b7778805db3815e8dd6cf09a"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::putchar" ref="af4de2514b7778805db3815e8dd6cf09a" args="(int c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int putchar </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send one byte via hardware UART. Required for printf() etc. in stdio.h </p>

</div>
</div>
<a class="anchor" id="a5a0c8f1d5aaf7c4ce53ad9af0fe110ec"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::setLed" ref="a5a0c8f1d5aaf7c4ce53ad9af0fe110ec" args="(unsigned char led)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed int setLed </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>led</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Turns ON the specified LED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>led</em>&nbsp;</td><td>the LED to turn on, must be 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The specified LED is turned on. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if success, -1 if invalid LED specified </dd></dl>

</div>
</div>
<a class="anchor" id="a865c94e017f6ddb42d2e0e51f6a395c1"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::setZnpInterfaceToInputs" ref="a865c94e017f6ddb42d2e0e51f6a395c1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setZnpInterfaceToInputs </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures all ZNP interface signals as inputs to allow the ZNP to be programmed. Toggles LED0 quickly to indicate application is running. </p>

</div>
</div>
<a class="anchor" id="a8653a168989b0498a6bbfe865150d58c"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::spiWrite" ref="a8653a168989b0498a6bbfe865150d58c" args="(unsigned char *bytes, unsigned char numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spiWrite </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a message over SPI to the ZNP. Based on hal_board.c in CC2480 example application ZASA. The ZNP uses a "write-to-read" approach: to read data out, you must write data in. This is a private method that gets wrapped by other methods, e.g. spiSreq(), spiAreq, etc. To Write, set *bytes and numBytes. To Read, set *bytes only. Don't need to set numBytes because CC2530ZNP will stop when no more bytes are received. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bytes</em>&nbsp;</td><td>the data to be sent or received. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numBytes</em>&nbsp;</td><td>the number of bytes to be sent. This same buffer will be overwritten with the received data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>SPI port configured for the ZNP </dd>
<dd>
CC2530ZNP has been initialized </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>bytes contains received data, if any </dd></dl>

</div>
</div>
<a class="anchor" id="a84e7d920fe8baceca080352f2c9c6fb0"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::toggleLed" ref="a84e7d920fe8baceca080352f2c9c6fb0" args="(unsigned char led)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed int toggleLed </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>led</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Toggles the specified LED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>led</em>&nbsp;</td><td>the LED to toggle, must be 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The specified LED is toggled. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if success, -1 if invalid LED specified </dd></dl>

</div>
</div>
<a class="anchor" id="a1c27b12dfd9998dbc915bee092a83447"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::USCIAB0RX_ISR" ref="a1c27b12dfd9998dbc915bee092a83447" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__interrupt void USCIAB0RX_ISR </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Debug console interrupt service routine </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a5a2a60dd6e60be649eb41d656a73cb94"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::accelerometerIsr" ref="a5a2a60dd6e60be649eb41d656a73cb94" args=")(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="hal__cc2530znp__target__board_8c.html#a5a2a60dd6e60be649eb41d656a73cb94">accelerometerIsr</a>)(void)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function pointer for the ISR called when the accelerometer generates an interrupt </p>

</div>
</div>
<a class="anchor" id="adba3edf29f085eb5465a9d028be99143"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::buttonIsr" ref="adba3edf29f085eb5465a9d028be99143" args=")(char)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="hal__mdb1_8c.html#adba3edf29f085eb5465a9d028be99143">buttonIsr</a>)(char)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function pointer for the ISR called when the button is pressed </p>

</div>
</div>
<a class="anchor" id="a8ae091a60a9e1f4eef0b56268ed1f36b"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::debugConsoleIsr" ref="a8ae091a60a9e1f4eef0b56268ed1f36b" args=")(char)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="hal__mdb1_8c.html#a8ae091a60a9e1f4eef0b56268ed1f36b">debugConsoleIsr</a>)(char)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is a function pointer for the Interrupt Service Routine called when a debug console character is received. To use it, declare it with <code> extern void (*debugConsoleIsr)(char); </code> and then point it to a function you created, e.g. <code> debugConsoleIsr =  </code> and your function handleDebugConsoleInterrupt() will be called when a byte is received. </p>

</div>
</div>
<a class="anchor" id="a20e13adfc540d264097a7733c36d65a7"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::srdyIsr" ref="a20e13adfc540d264097a7733c36d65a7" args=")(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="hal__cc2530znp__target__board_8c.html#a20e13adfc540d264097a7733c36d65a7">srdyIsr</a>)(void)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function pointer for the ISR called when a SRDY interrupt occurs </p>

</div>
</div>
<a class="anchor" id="aaf473d7d866976957729b47a5554a4ad"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::timerIsr" ref="aaf473d7d866976957729b47a5554a4ad" args=")(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="hal__mdb1_8c.html#aaf473d7d866976957729b47a5554a4ad">timerIsr</a>)(void)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function pointer for the ISR called when a timer generates an interrupt </p>

</div>
</div>
<a class="anchor" id="a1d9ae5b74e1b201388cff33a7537d3c4"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::vloFrequency" ref="a1d9ae5b74e1b201388cff33a7537d3c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="hal__cc2530znp__target__board_8c.html#a1d9ae5b74e1b201388cff33a7537d3c4">vloFrequency</a> = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The post-calibrated frequency of the Very Low Oscillator (VLO). Set with <a class="el" href="hal__cc2530znp__target__board_8c.html#aea54cfa0b896d2e756d3eb75273a1710">calibrateVlo()</a> and read by <a class="el" href="hal__cc2530znp__target__board_8c.html#a8861ee0f29013d6fed16952a41d986c0">initTimer()</a>. </p>

</div>
</div>
<a class="anchor" id="ade29a27c903a705ca10a52e6d690e7ac"></a><!-- doxytag: member="hal_cc2530znp_target_board.c::wakeupFlags" ref="ade29a27c903a705ca10a52e6d690e7ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="hal__cc2530znp__target__board_8c.html#ade29a27c903a705ca10a52e6d690e7ac">wakeupFlags</a> = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flags to indicate when to wake up the processor. These are read in the various interrupt service routines and if the flag is set then the processor will be woken up with HAL_WAKEUP() at the end of the ISR. This is required because HAL_WAKEUP() cannot be called anywhere except in an ISR. </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Aug 19 11:48:31 2010 for Hardware Abstraction Layer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
